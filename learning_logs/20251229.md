# 금일 수업 계획
1. IntelliJ 설치
    - chrome에서 IntelliJ 검색 -> 다운로드 -> Bin PATH 체크 후 설치하기 / 나머지는 default 값.
2. Visual studio code 설치
    - chrome에서 Visual studio code 검색 -> 다운로드 -> Bin PATH 체크 후 설치하기 / 나머지는 default 값.
3. Git 설치
    - chrome에서 git 검색 -> install for windows 클릭
4. 프로젝트 생성 방법
    - window + e : 탐색기 
    - 로컬디스크(C:)에 우클릭 -> 새로 만들기 -> 폴더 -> 여러분 영어 이름 소문자로 생성
    - window + intelliJ 검색해서 실행
    - build.gradle에서 
    java {
      toolchain {
        languageVersion = JavaLanguageVersion.of(17)
      }
    } 확인하기
5. 깃허브 확인 방법
   - 강사님 깃허브 아이디 : maybeags
   - https://www.github.com/maybeags

# Java Review
1. 자료형 (type)
   1. 기본 자료형 (Primitive Types)
      1. 숫자 관련
         - 정수 관련
           - int, long
         - 실수 관련
           - double, float
         - 왜 두개씩 있나? : 용량 문제 ch04_conversion 확인
      2. 문자 관련
         - 문자 (char)
   2. 참조 자료형 (Reference Types)
      1. 문자 관련
         - 문자열 (String) : 문자가 '순서대로' 나열되어 있다는 점. 
           - 안근수 / 수근안 : 동일한 문자들로 구성되어있지만 순서가 다르기 때문에 차이가 있음.
           - 안 + 근 + 수 / 수 + 근 + 안의 결과값이 다릅니다.
           - 숫자의 경우에는 1 + 2 + 3 / 3 + 2 + 1이 결과값이 동일한 것과는 차이가 있습니다.

2. 변수 (Variable) : 데이터(값)을 담는 바구니(인데 이름을 붙여줘야 함).
   1. 변수 명명 규칙
      - Camel case를 사용할 것.
        - Camel case : 시작은 소문자로, 다수의 단어로 이루어졌을 경우 두 번째 이후 단어의 첫 번째 알파벳은 대문자로 입력할 것.
        - 예시 :
          - 단수 단어 : result
          - 복수 단어 : myTestResult
        - Pascal case : 시작은 대문자로, 다수의 단어로 이루어졌을 경우 두 번째 이후 단어의 첫 번째 알파벳은 대문자로 입력할 것. 
          나머지는 소문자
          - Pascal case는 클래스 명명 규칙에 해당합니다.
        - 예시 :
          - 단수 단어 : Result
          - 복수 단어 : MyTestResult
   2. 변수 선언 및 초기화
      - 자료형 변수명 = 데이터;
```java
public static void main (Stirng[] args) {
// 자료형 변수명 = 데이터;
   int age = 20;
   
   // 변수 선언 : 앞으로 해당 변수가 사용될거라는 것을 선언
   String name;
   // 초기화 : 특정 변수에 처음으로 값을 대입하는 것.
   name = "김일";
   // 재대입 : 특정 '변수'에 값을 바꿔주는 것.
   name = "김이";
}
```
   3. 상수 : 데이터가 초기화 이후 재대입이 불가능한 변수를 의미함.
```java
public static void main(String[] args) {
// final 자료형 변수명 = 데이터;    
    final int age = 12;     // 상수라는 것을 알리기 위해서 camel case를 쓰지 않고 대문자로 작성함.
    // age = 13;            - 재대입하려고 하면 오류가 발생함.
}
```
   - 상수 명명 규칙
     - camel case를 적용하지 않고 전부 다 대문자로 작성함. 복수 단어로 이루어져있을 경우 단어 경계에 언더바(언더스코어 : '_')를 사용.
     - 예시 : 
       1. 단수 단어 : RESULT
       2. 복수 단어 : MY_TEST_RESULT

3. Conversion(형변환) : 특정 변수 (객체)를 다른 자료형으로 변환시키는 것.
   1. upcasting : 특정 변수(객체)를 더 큰 용량의 자료형으로 변환시키는 것.
      - 암시적(implicit)으로 이루어짐 : 작은 용량에서 큰 용량으로 변환시킬 때는 데이터의 값이 
      변질되지 않기 때문에 직접적으로 바뀔 자료형으로 명시하지 않아도 됨.
   2. downcasting : 특정 변수(객체)를 더 작은 용량의 자료형으로 변환시키는 것.
      - 명시적(explicit)으로 이루어짐 : 더 큰 용량에서 작은 용량으로 바꾸게 될 경우 용량 제한으로 인해
        데이터의 값이 변질될 수 있기 때문에 직접적으로 자료형으로 명시해야만 함.
```java
public static void main(String[] args) {
    // 변수 선언 및 초기화
    char cast1 = 'A';
    // 1. 업캐스팅 # 1 : (바뀔 데이터 타입) : 변수명;
    System.out.println("변형 : " + (int)cast1);        // 결과값 : 65
    // 2. 업캐스팅 # 2
    int casted1 = cast1;        // 이 부분이 '암시적'
    
    // 다운캐스팅 용 변수 선언 및 초기화
    int cast2 = 97;
    // 3. 다운캐스팅 # 3 : (바뀔 데이터 타입) 변수명;
    System.out.println("변형 : " + (char)cast2);          // 결과값 : a
    // 4. 다운캐스팅 # 4
    char casted2 = (char)cast2;         // 이 부분이 '명시적'
}
```

4. Operator(연산자)
   1. 대입 연산자 '=' : '=' 왼쪽에 있는 변수에 "=" 오른쪽에 있는 데이터(값)를 '대입'한다는 의미.
      즉, a = b라고 했을 때 a와 b의 값이 같다 라는 의미가 아니라는 점에 주목해야 합니다.
      - 같다고 이야기 하고 싶다면 '=='을 씁니다. 근데 JavaScript에서는 '=='도 있고, '==='도 있습니다.
   2. `+ - * /` : 수학이랑 똑같습니다. - 문자, 문자열 자료형의 경우에도 + 연산자는 적용이 가능
   3. % : 나머지 연산자 - 나누고 나서 남는 나머지를 명시함. 즉 결과값은 int, long이어야 함.
   4. 복합대입연산자
      1. +=
      2. -=
      3. *=
      4. /=
   5. `++ / --`
```java
public static void main(String[] args) {
   int num = 1;
   System.out.println(num++);       // 결과값 : 1
   System.out.println(num);         // 결과값 : 2
   System.out.println(++num);       // 결과값 : 3
   System.out.println(num);         // 결과값 : 3
   System.out.println(num--);       // 결과값 : 3
   System.out.println(num);         // 결과값 : 2
   System.out.println(--num);       // 결과값 : 1
}
```
5. Condition(조건문) : 조건식 내의 return값이 true / false에 따라서 특정 부분을 실행시키는 제어문
```java
/*
public static void main(String[] args) {
    if(조건식 1) {
        실행문 1
        if(조건식 1-a) {
            실행문 1-a
      } else if(조건식 1-b) {
            실행문 1-b
      } else if (조건식 1-c) {
            실행문 1-c            
      } else {
            실행문 2-b
      } else if (조건식2) {
            실행문 2-1
            if (조건식 2-a) {
                실행문 2-a
         } else {
                실행문 3
         }
      }
   }
   */

```
   1. 용어 정리 
      1. 조건식 : true / false로 결정이 날 수 있는 boolean 자료형을 return하는 식
      2. 실행문 : if, else if, else 이후의 {} 내의 영역으로 특정 조건을 만족했을 경우 실행되는 코드 혹은 식.
   2. 반복문과의 유의사항
      - 반복문은 특정 조건을 만족했을 경우 '반복'실행되는데 반해, 조건문은 해당 조건에 해당되는 부분을 '한 번' 실행합니다.]
      그래서 if-else if-else 전체를 한 세트로 봐야합니다.
   3. switch문
```java
public static void main(String[] args) {
   // 사용할 클래스 import
   Scanner scanner = new Scanner(System.in);
   // 변수 선언 및 초기화
   int menu = 0;

   System.out.println("[메뉴 선택]");
   System.out.println("1. 자바");
   System.out.println("2. 자바스크립트");
   System.out.println("3. 파이썬");
   System.out.println("4. HTML");

   System.out.print("메뉴를 선택하세요 >> ");
   menu = scanner.nextInt();
   
   switch (menu) {
      case 1 :
         System.out.println("자바를 공부한다.");
         break;
      case 2 :
         System.out.println("자바스크립트를 공부한다.");
         break;
      case 3 :
         System.out.println("파이썬를 공부한다.");
         break;
      default :
         System.out.println("HTML를 공부한다.");
   }
}
```
6. Loop (반복문)
   1. while
```java
public static void main(String[] args) {
    int i = 0;
    while (i < 100) {    // () 내부의 조건식이 true일 때 실행 - 무한 루프를 조심해야 함.
        if (i % 2 == 0) {
            System.out.println(i + "는 짝수입니다.");
        } else {
            System.out.println(i + "는 홀수입니다.");
        }
        i++;        // 특정조건에서 while 반복문을 탈출하기 위해서 통제할 필요가 있음.
        System.out.println("다음 숫자로 넘어갑니다.");
    }
}
```
   2. for
```java
public static void main(String[] args) {
   // for(시작값; 한계값; 증감값)
   for (int i = 0; i < 100; i++) {
      if (i % 2 == 0) {
         System.out.println(i + "는 짝수입니다.");
      } else {
         System.out.println(i + "는 홀수입니다.");
      }
   }
}
```
   3. 주의사항 
      - while문의 경우에는 무한 루프에 빠지지 않도록 특정 조건하에서 반복문을 탈출할 수 있게끔 작성할 필요가 있음.
      - for문의 경우에는 한계값을 초반부에 명시하고, 그 반복횟수를 int로 정리한다는 점을 생각해둘 것. 
      while문의 경우에는 조건식이 String일 수도 있죠.
        - 증감값을 통해 반복횟수를 통제한다는 점에서,
      - while 문 : 특정 조건 하에서만 반복실행되게 통제할 때 사용.
      - for 문 : 명확한 반복 횟수를 통제할 때 사용.

# 금일 수업내용
1. Overloading
   - method Overloading
   : 매개변수의 유무 및 자료형의 차이, 개수의 차이를 나눠서 동일한 메서드 명을 지닌 메서드'들'을 정의할 수 있다.
   : 즉, 메서드 명은 동일하고, 매개변수에 들어가는 자료형, 개수를 달리하게 되면 서로 다른 메서드로 인지하게 됩니다.
   : 예를 들어서 숫자끼리 더하는 메서드가 있다고 가정하겠습니다.
     걔를 add()라고 정했다고 칩시다.
   
   ```java
   public int add(int a, int b) {
            return a + b;
        }
    ```
   
   근데 문자열끼리 더하는 게 필요해서 add는 못쓰니까 connect를 씁시다.
        
    ```java
   public String connect(String a, String b) {
            return a + b;
        }
   ```
   근데 뒤집어서 연결해야 할 때가 있어서
        
   ``` java
   public String connect(String a, String b) {
            return b + a;
        }
   ```
   
   근데 정수 더하기 실수 해야해서
        
   ```java
   public double plus(int a, double b) {
            return a + b;
        }
   ```
   이런 부분이 문제가 됩니다.
   
     - method overloading의 장점 
   
     : 동일한 기능을 하는 메서드를 정의할 때 메서드 명이 필요한데,
     예를 들어 String 자료형끼리 연결해주는 메서드와
     int끼리의 합 연산을 하는 메서드를 나눈다고 가정했을 때,
     add,
     plus,
     connect 등을 정의했다면,
     다음 합 연산을 하는 (예를 들어 double 자료형을 지니는) 메서드 명을 정하려고 하면 번거롭습니다.
     
   ```java
     public void add(String example1, String example2) {
        로직
     }
     ```
   ```java
     public void add(int example1, int example2) {
        로직
     }
   ```
   ```java
     public void add(double example1, double example2) {
        로직
     }
   ```
     과 같이 자료형을 달리 하는 '동일한 이름을 가지는 메서드들'을 정의하거나,
   ```java
     public void add(String example1, String example2, String example3) {
        로직
     }
   ```
     와 같은 식으로 매개변수의 개수의 차이를 두더라도 '동일한 기능을 하는
     서로 다른 메서드'들로 인식하게끔 하는 방식입니다.
     그러면 메서드 명들도 동일하고, 걔네가 뭐 매개변수 유형이 개수가 차이가 있겠지만,
     기능도 같으니까 머리가 안아프다는 장점이 있다고 할 수 있습니다.

2. Class란?
    : 객체를 생성하기 위한 설계도 = 틀 / 청사진
      현실 세계의 개념을 프로그래밍으로 표현할 때,
      "특정 사물이나 개념의 특징(속성)"과 "행위(메서드)"로 정의함.
      예로 들어,
      "자동차"라는 클래스를 생성한다면 자동차의 속성 (색상, 속도)과,
      행위 (가속, 정지 등)를 코드로 표현할 수 있음.

3. 객체 (Object)란?
    : 클래스를 설계도로 가정했을 때,
      실제 사용할 수 있는 자동차 (인스턴스)는 객체라고 함.
      Object와 Instance는 우리나라에서는 거의 동일한 용어로 사용됩니다.

4. 객체와 인스턴스 관계
    : 객체는 포괄적인 개념으로 클래스에서 생성된 모든 것을 객체라고 표현
      인스턴스는 특정 객체가 어떤 클래스의 구현체인지 강조하는 표현

5. 비유로 이해하기
    1. "사람"이라는 클래스가 있다고 가정한다면,
    2. "홍길동", "김철수"는 이 클래스에서 생성된 객체임. 근데 "아반떼"도 객체임
    3. "홍길동"은 "사람"이라는 특정 클래스의 '인스턴스'임. 아반떼는 아님.