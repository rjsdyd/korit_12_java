# Object 클래스
- _모든 클래스는 Object 클래스를 상속_ 받는다.
그래서 interface를 implements 할 때나 다른 서브 클래스를 만들어서
extends 입력했다고 했을 때 우리가 직접 만들었던 슈퍼 클래스 이외에 
alt + ins 눌러보면 toString() 어쩌고 한 메서드들이
추가되어있었습니다.

1. toString() : 기본적으로 모든 클래스는 Object 클래스를 상속 받아서 클래스 이름과 해시코드(일종의 주소지 개념)를 return함.
    - 이를 Override 하여 재정의하고 클래스의 정보를 출력할 때 사용.
    - field를 정의하고, toStiring() 메서드를 override해서 필요한
    field들을 출력함 (name만 혹은 address만도 가능합니다.) -> 추가적으로
    객체의 이름만으로 출력이 가능하기 때문에
    `System.out.println(객체명.toString())`이 아니라,
    `System.out.println(객체명)`로 할 수 있음.
2. equals() : 두 객체가 '논리적으로 같은지'를 비교하는 메서드
(주소지의 차이가 아니라). 기본적으로 object 클래스의 equals() 메서드는 두 객체의 참조 주소를 비교.
    - 형식 : 객체명1.equals(객체명2) : 객체명1과 객체명2의 참조 주소가 동일한지를 확인함. - 3형식 문장으로 해석하시면 됩니다 SVO.
3. hashCode() : 객체를 정수값(해시값)으로 변환 (16진수가 아니라).
해시 값은 주로 해시 기반 컬렉션에서 사용.
    - equals() 메서드를 재정의하게 되면 반드시 hashCode() 메서드도 재정의해야만 함. 왜냐면 동일한 객체 (equals == true)는 동일한 해시 코드를 가져야하기 때문인데, 문제는 해시코드가 같다고 해서 또 equals()가 또 true가 아닌 경우가 있기 때문.

# Lombok
좌측 상단의 메뉴바 -> 설정 -> 플러그인 -> lombok -> 설치

chrome -> mvn 검색 -> maven repositories로 들어가서 lombok 검색 -> 최신버전 설치 -> groovy short 복사 -> build.gradle에 추가 -> annotationProcessor도 추가
```java
dependencies {
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    implementation 'org.projectlombok:lombok:1.18.42'
    annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```
## Lombok 주요 annotation
1. @Getter / @Setter
    - class level에 작성할 경우 모든 getter / setter 메서드를 자동 생성
    - field level에 작성할 경우 해당 field 에만 메서드 생성
```java
@Setter
@Getter
public class Person{
    private String name;
    private int age;
}
```
2. @TOString
    - toString() 메서드를 자동생성. 문제는 재정의가 안되고 Lombok 라이브러리 default 형태만 나오기 떄문에 원하는 부분만 보여주기 위해서는 override 할 필요가 있음

3. @EqualAndHashCode
    - equals() / hashCode() 메서드를 자동생성. 객체의 동일성 비교 로직을 구현할 때 사용
        - 아까 학습한 것처럼 equals()를 재정의하면 hashCode()도 반드시 재정의해야하기 때문에 롬복에서는 세트로 묶음

4. @NoArgsCOnstructor / @RequiredArgsConstructor / @AllArgsConsturctor
    - @NoArgsCOnstructor : 매개 변수가 없는 기본 생성자를 생성
    - @RequiredArgsConstructor : final 또는 `@NonNull` 애너테이션이 붙은 field만 필수적으로 요구하는 매개변수 생성자를 생성
    - @AllArgsConsturctor : 모든 field를 argument로 요구하는 매개변수 생성자

5. @Data
    - @Getter / @Setter / @TOString / @EqualAndHashCode / @RequiredArgsConstructor가 다 들어가있는 종합 패키지 애너테이션

6. @Builder - 추후 학습

UserEntityLombok 클래스 만들겠습니다.

# Static

## 정의
    - 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
    - static으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않음.'(즉 객체마다 다른 값을 가지는 것이 인스턴스변수였는데, 그게 아니라 해당 클래스의 인스턴스가 전부 동일한 값을 공유함을 의미합니다)
    - 클래스 자체에 속하게 됨.
    - 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 field, method와 구분됩니다.

## 특징
    1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근합니다. 따라서 데이터를 공유하거나 상태를 저장할 때 유용.
    2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드 시 메모리에 할당(객체가 생성될 때가 아니라).


```java
// 일반 field에 미리 초기화를 해두는 방식 : 객체가 생성될 때마다 동일한 내용이 반복적으로 메모리에 할당됨.
@Setter
@Getter
public class KoreaItStudent12 extends KoreaItStudent {

    // field 선언
    private String name;
    private int age;
    private String address;
    private String introduction = "코리아 아이티 국비 과정 12월";
}

public class Main {
    public static void main(String[] args) {
        KoreaItStudent12 student1 = new KoreaItStudent12();
        student1.setName("김일");
        student1.setAge(20);
        student1.setAddress("부산광역시 부산진구");
        System.out.println(student1.getIntroduction()); // 결과값 : 코리아 아이티 국비 과정 12월
    }
}
```
```java
// 정적 변수의 선언으로 클래스가 메모리에 마운트 될때 1 번 저장.
// 이후 객체가 생성될 때마다 동일한 introduction field를 가지게 됨.
@Setter
@Getter
public class KoreaItStudent12 extends KoreaItStudent {
    // 정적 변수 선언
    private static String introduction = "코리아 아이티 국비 과정 12월";

    // field 선언
    private String name;
    private int age;
    private String address;
    // private String introduction = "코리아 아이티 국비 과정 12월";
}

public class Main {
    public static void main(String[] args) {
        KoreaItStudent12 student1 = new KoreaItStudent12();
        student1.setName("김일");
        student1.setAge(20);
        student1.setAddress("부산광역시 부산진구");
        System.out.println(student1.getIntroduction()); // 결과값 : 코리아 아이티 국비 과정 12월
    }
}
```

이상의 KoreaItStudent12 클래스의 인스턴스들은 다 동일한 private static String '정적 변수'를 갖게 됩니다. 즉, 어느 클래스의 인스턴스인지만 확인하더라도 몇 월 국비생인지를 확인할 수 있겠네요.
    
    3. 인스턴스가 필요없음 : 객체를 생성하지 않고도 클래스명.field / 클래스명.메서드명() 형태로 접근이 가능합니다(이때는 private이 아니어야겠네요)
    4. 메모리 효율성 : static 변수는 프로그램이 종료될 때까지 한 번만 메모리에 할당됨(객체가 생성될 때마다가 아니라).

# Builder Patten(빌더 패턴)
```java
@AllArgsConstructor
public class Student {
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private String[] subjects;
    private double[] scores;
}
public class StudentMain {
    public static void main(String[] args) {
        Student student = new Student("여기 내부에 모든 field를 순서대로 작성");
    }
}
```

## 빌더 패턴이 생기게 된 이유
1. 복잡한 생성자 문제
   - 객체의 field가 많아질 수록 생성자 매개변수 수도 늘어남.
     - 저희는 롬복 쓰니까 생성자 코드 라인이 적을 수 있지만
     - 필수적인 부분에 @NonNull이나 final을 써야하고, 그 와중에 final 쓰면 기본 생성자는 못만드는 등 여러가지 제약이 있습니다.
2. 생성자 오버로딩 문제
    - 생성자에 필요한 조합이 다를 경우 수많은 생성자를 하나씩 정의해야 합니다.
      - 예를 들어 옛날 회원가입의 경우 집전화와 폰번호가 필수 였는데, 오늘날에는 집전화는
      optional인 상태죠. 그럼 처음에는 homePhone field에 final 넣었다가 나중에는
      뺏다가 그러면 거기에 맞춰서 생성자도 homePhone field를 넣어놨는데 나중에는 
      그거 삭제해야하고 하여튼 귀찮은 상황이 발생합니다.

    - 유지보수에 악영향 / 예를 들어 field 하나 추가하면 AllArgsConstructor가 아니게 되니까 다 뜯어 고쳐야하곘네요.
    저희가 VolumeUpButton 추가했을 때 생성자 뜯어내고 Main에서 생성자 호출할 때도 오류 수정했던 것을 떠올리면 되겠습니다.
3. 가독성 문제
    - 코드를 작성하고 읽는 입장에서는 객체를 생성할 때 어떤 값이 어떤 field에 해당하는지 명확하지 않아서 실수를 유발
```java
public static void main(String[] args) {
    Student student = new Student("김일", "김이");
}
```
## 정의
객체의 생성과정에서 '복잡한 생성자'를 대신하여 '단계적'으로 객체를 생성할 수 있는 디자인 패턴 중 생성 파트 관련.
GoF 디자인 패턴 중 하나로 객체 생성 시 가독성과 유연성을 제공하는 것이 목표

- 이상에서의 유연성의 의미는 field를 '순서대로' 채워넣지 않아도 되고, 
순서를 바꾸더라도 정확한 field에 원하는 값을 집어넣을 수 있다는 것을 의미합니다.

## 특징
1. 객체를 생성하는 여러 개의 field를 '명시적'으로 관리할 수 있음.
2. 불필요한 생성자 오버로딩을 줄여 가독성을 높임
3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성